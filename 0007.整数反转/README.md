# [7.整数反转](https://leetcode.cn/problems/reverse-integer/)

`时间：2023.6.23`

## 题目

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−231,  231 − 1]` ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

**示例1：**

```
输入：x = 123
输出：321
```

**示例2：**

```
输入：x = -123
输出：-321
```

**示例3：**

```
输入：x = 120
输出：21
```

**示例4：**

```
输入：x = 0
输出：0
```

## 代码

#### 方法：数学方法

##### 思路

实际上我们只要能拿到这个整数的 **末尾数字** 就可以了。

有些数字可能是合法范围内的数字，但是**反转**过来就超过范围了。

所以，我们到【最大数的1/10】时，就要开始判断了

如果某个数字**大于** 214748364那后面就不用再判断了，肯定溢出了。

如果某个数字**等于** 214748364呢，这对应到上图中第三、第四、第五排的数字，需要要跟最大数的末尾数字比较，如果这个数字比7还大，说明溢出了。

对于负数也是一样的

##### 代码

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while (x != 0) {
            //取末尾数字
            int temp = x % 10;
            //判断是否大于最大32位整数
            if (res > Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 && temp > 7))
                return 0;
            //判断是否小于最小32位整数
            if (res < Integer.MIN_VALUE / 10 || (res == Integer.MIN_VALUE / 10 && temp < -8))
                return 0;
            res = res * 10 + temp;
            x /= 10;
        }
        return res;
    }
}
```

##### 复杂度分析

- 时间复杂度：O(log|x|)，翻转的次数即x十进制的位数。
- 空间复杂度：O(1)。
